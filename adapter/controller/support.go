//Package controller generated by 'freedom new-project cdp-service'
package controller

import (
	"cdp-service/adapter/repository"
	"cdp-service/domain"
	"cdp-service/domain/vo"
	"cdp-service/infra"

	"github.com/8treenet/freedom"
)

func init() {
	freedom.Prepare(func(initiator freedom.Initiator) {
		initiator.BindController("/support", &SupportController{})
	})
}

// SupportController .
type SupportController struct {
	SupportService  *domain.SupportService
	Worker          freedom.Worker
	Request         *infra.Request
	Common          *infra.CommonRequest
	ClondRepository *repository.ClondRepository
}

//Get handles the GET: /support/source route.
func (support *SupportController) PostSource() freedom.Result {
	var data struct {
		Source string `json:"source" validate:"required"`
	}
	if e := support.Request.ReadJSON(&data, true); e != nil {
		return &infra.JSONResponse{Error: e}
	}
	if e := support.SupportService.CreateSource(data.Source); e != nil {
		return &infra.JSONResponse{Error: e}
	}

	return &infra.JSONResponse{}
}

//Get handles the GET: /support/sources route.
func (support *SupportController) GetSources() freedom.Result {
	all, e := support.SupportService.GetAllSource()
	if e != nil {
		return &infra.JSONResponse{Error: e}
	}

	objects := make([]struct {
		ID     int    `json:"id"`
		Source string `json:"source"`
	}, len(all))

	for i := 0; i < len(all); i++ {
		objects[i].ID = all[i].ID
		objects[i].Source = all[i].Source
	}
	return &infra.JSONResponse{Object: objects}
}

//GetFeatures handles the GET: /support/features route.
func (support *SupportController) GetFeatures() freedom.Result {
	list, total, e := support.SupportService.GetFeaturesByPage()
	if e != nil {
		return &infra.JSONResponse{Error: e}
	}
	page, pageSize := support.Common.GetPage()
	pageData := infra.PageResponse{
		List:     list,
		Total:    total,
		Page:     page,
		PageSize: pageSize,
	}
	return &infra.JSONResponse{Object: pageData}
}

//PostFeature handles the Post: /support/feature route.
func (support *SupportController) PostFeature() freedom.Result {
	var dto vo.ReqFeatureDTO
	if e := support.Request.ReadJSON(&dto, true); e != nil {
		return &infra.JSONResponse{Error: e}
	}
	if e := support.SupportService.CreateFeature(dto); e != nil {
		return &infra.JSONResponse{Error: e}
	}

	return &infra.JSONResponse{}
}

//PutFeature handles the Post: /support/feature/:int route.
func (support *SupportController) PutFeatureBy(featureId int) freedom.Result {
	var dto []vo.ReqFeatureMetadataDTO
	if e := support.Request.ReadJSON(&dto, true); e != nil {
		return &infra.JSONResponse{Error: e}
	}
	if e := support.SupportService.AddFeatureMetadata(featureId, dto); e != nil {
		return &infra.JSONResponse{Error: e}
	}

	return &infra.JSONResponse{}
}

//GetClondUptoken handles the Get: /support/clond/uptoken route.
func (support *SupportController) GetClondUptoken() freedom.Result {
	token, e := support.SupportService.GetClondUploadTopen()
	if e != nil {
		return &infra.JSONResponse{Error: e}
	}
	return &infra.JSONResponse{Object: token}
}

//PostClondKey handles the Get: /support/clond/key route.
func (support *SupportController) PostClondKey() freedom.Result {
	var data struct {
		Key string `json:"key" validate:"required"`
	}
	if e := support.Request.ReadJSON(&data, true); e != nil {
		return &infra.JSONResponse{Error: e}
	}

	e := support.SupportService.CreateClondKey(data.Key)
	if e != nil {
		return &infra.JSONResponse{Error: e}
	}
	return &infra.JSONResponse{}
}

//PostClondKey handles the Get: /support/clond/keys route.
func (support *SupportController) GetClondKeys() freedom.Result {
	result, totalPage, e := support.SupportService.GetClondKeysByPage()
	if e != nil {
		return &infra.JSONResponse{Error: e}
	}

	page, pageSize := support.Common.GetPage()
	pageData := infra.PageResponse{
		List:     result,
		Total:    totalPage,
		Page:     page,
		PageSize: pageSize,
	}
	return &infra.JSONResponse{Object: pageData}
}
